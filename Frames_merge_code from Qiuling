import os
import subprocess
import tempfile
import shutil


def create_video(input_folder, output_file, is_hdr=False):  
    """
    从图片序列创建视频，确保所有帧都被正确处理

    Args:
        input_folder (str): 输入图片文件夹路径
        output_file (str): 输出视频文件路径
        is_hdr (bool): 是否为HDR视频
    """
    # 确保输出目录存在
    os.makedirs(os.path.dirname(output_file), exist_ok=True)

    # 获取输入文件夹中的所有图片并按系统原始顺序排列
    image_extensions = ('.png', '.jpg', '.jpeg', '.bmp', '.tiff')
    images = []
    for f in os.listdir(input_folder):
        # 检查文件扩展名和是否为文件
        if f.lower().endswith(image_extensions) and os.path.isfile(os.path.join(input_folder, f)):
            images.append(f)

    if not images:
        raise Exception(f"在 {input_folder} 中没有找到图片文件")

    print(f"找到 {len(images)} 张图片，将按文件夹中的原始顺序合成视频")

    # 创建临时目录用于复制文件（解决特殊字符和路径问题）
    with tempfile.TemporaryDirectory() as temp_dir:
        # 复制文件并按顺序重命名（0001.png, 0002.png...）
        for i, img in enumerate(images, 1):
            src_path = os.path.join(input_folder, img)
            # 重命名为连续编号，确保FFmpeg能正确识别序列
            dst_name = f"{i:08d}{os.path.splitext(img)[1].lower()}"
            dst_path = os.path.join(temp_dir, dst_name)
            shutil.copy2(src_path, dst_path)

        # 构建ffmpeg命令，直接读取编号序列
        cmd = [
            'ffmpeg', '-y',
            '-framerate', '60',
            # 使用通配符读取连续编号的图片
            '-i', os.path.join(temp_dir, '%08d.png'),
            '-vf', 'setpts=PTS-STARTPTS',  # 重置时间戳
            '-c:v', 'libx265',
            '-b:v', '30000k',
            '-maxrate', '30000k',
            '-bufsize', '60000k',
            '-crf', '18',
            '-preset', 'medium'
        ]

        if is_hdr:
            # HDR参数
            cmd.extend([
                '-pix_fmt', 'yuv420p10le',
                '-x265-params', 'colorprim=bt2020:transfer=smpte2084:colormatrix=bt2020nc:level=5.1:high-tier=1'
            ])
        else:
            # SDR参数
            cmd.extend([
                '-pix_fmt', 'yuv420p',
                '-x265-params', 'colorprim=bt709:transfer=bt709:colormatrix=bt709:level=5.1'
            ])

        # 添加输出文件
        cmd.append(output_file)

        # 执行ffmpeg命令
        try:
            print(f"开始合成视频: {output_file}")
            result = subprocess.run(
                cmd,
                check=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                encoding='utf-8'
            )
            print(f"成功创建视频: {output_file}")
            print(f"处理了 {len(images)} 帧")
        except subprocess.CalledProcessError as e:
            print(f"创建视频时发生错误: {e}")
            print("FFmpeg输出:")
            print(e.output)
            raise
        except Exception as e:
            print(f"执行命令时发生异常: {str(e)}")
            raise  


def main():
    # 配置路径
    sdr_folder = r"D:\Youtube\帧\SDR1"
    hdr_folder = r"D:\Youtube\帧\HDR1"
    output_folder = r"D:\Youtube"

    try:
        # 生成SDR视频
        sdr_output = os.path.join(output_folder, "SDR", "sdr.mkv")
        create_video(sdr_folder, sdr_output, is_hdr=False)

        # 生成HDR视频
        hdr_output = os.path.join(output_folder, "HDR", "hdr.mkv")
        create_video(hdr_folder, hdr_output, is_hdr=True)

        print("所有视频生成完成!")
    except Exception as e:
        print(f"处理过程中出错: {str(e)}")


if __name__ == "__main__":
    main()
